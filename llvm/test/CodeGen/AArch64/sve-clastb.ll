; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 3
; RUN: llc -mtriple=aarch64-linux-unknown -mattr=+sve -o - < %s | FileCheck %s

define i8 @clastb_i8(<vscale x 16 x i8> %data, <vscale x 16 x i1> %pg, i8 %existing) {
; CHECK-LABEL: clastb_i8:
; CHECK:       // %bb.0:
; CHECK-NEXT:    clastb w0, p0, w0, z0.b
; CHECK-NEXT:    ret
  %rev.pg = call <vscale x 16 x i1> @llvm.vector.reverse.nxv16i1(<vscale x 16 x i1> %pg)
  %tz.cnt = call i32 @llvm.experimental.cttz.elts.i32.nxv16i1(<vscale x 16 x i1> %rev.pg, i1 false)
  %any.set = call i1 @llvm.vector.reduce.or.nxv16i1(<vscale x 16 x i1> %pg)
  %vscale = call i32 @llvm.vscale.i32()
  %size = shl i32 %vscale, 4
  %sub = sub i32 %size, %tz.cnt
  %idx = sub i32 %sub, 1
  %extr = extractelement <vscale x 16 x i8> %data, i32 %idx
  %res = select i1 %any.set, i8 %extr, i8 %existing
  ret i8 %res
}

define i16 @clastb_i16(<vscale x 8 x i16> %data, <vscale x 8 x i1> %pg, i16 %existing) {
; CHECK-LABEL: clastb_i16:
; CHECK:       // %bb.0:
; CHECK-NEXT:    clastb w0, p0, w0, z0.h
; CHECK-NEXT:    ret
  %rev.pg = call <vscale x 8 x i1> @llvm.vector.reverse.nxv8i1(<vscale x 8 x i1> %pg)
  %tz.cnt = call i32 @llvm.experimental.cttz.elts.i32.nxv8i1(<vscale x 8 x i1> %rev.pg, i1 false)
  %any.set = call i1 @llvm.vector.reduce.or.nxv8i1(<vscale x 8 x i1> %pg)
  %vscale = call i32 @llvm.vscale.i32()
  %size = shl i32 %vscale, 3
  %sub = sub i32 %size, %tz.cnt
  %idx = sub i32 %sub, 1
  %extr = extractelement <vscale x 8 x i16> %data, i32 %idx
  %res = select i1 %any.set, i16 %extr, i16 %existing
  ret i16 %res
}

define i32 @clastb_i32(<vscale x 4 x i32> %data, <vscale x 4 x i1> %pg, i32 %existing) {
; CHECK-LABEL: clastb_i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    clastb w0, p0, w0, z0.s
; CHECK-NEXT:    ret
  %rev.pg = call <vscale x 4 x i1> @llvm.vector.reverse.nxv4i1(<vscale x 4 x i1> %pg)
  %tz.cnt = call i32 @llvm.experimental.cttz.elts.i32.nxv4i1(<vscale x 4 x i1> %rev.pg, i1 false)
  %any.set = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> %pg)
  %vscale = call i32 @llvm.vscale.i32()
  %size = shl i32 %vscale, 2
  %sub = sub i32 %size, %tz.cnt
  %idx = sub i32 %sub, 1
  %extr = extractelement <vscale x 4 x i32> %data, i32 %idx
  %res = select i1 %any.set, i32 %extr, i32 %existing
  ret i32 %res
}

define i64 @clastb_i64(<vscale x 2 x i64> %data, <vscale x 2 x i1> %pg, i64 %existing) {
; CHECK-LABEL: clastb_i64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    clastb x0, p0, x0, z0.d
; CHECK-NEXT:    ret
  %rev.pg = call <vscale x 2 x i1> @llvm.vector.reverse.nxv2i1(<vscale x 2 x i1> %pg)
  %tz.cnt = call i32 @llvm.experimental.cttz.elts.i32.nxv2i1(<vscale x 2 x i1> %rev.pg, i1 false)
  %any.set = call i1 @llvm.vector.reduce.or.nxv2i1(<vscale x 2 x i1> %pg)
  %vscale = call i32 @llvm.vscale.i32()
  %size = shl i32 %vscale, 1
  %sub = sub i32 %size, %tz.cnt
  %idx = sub i32 %sub, 1
  %extr = extractelement <vscale x 2 x i64> %data, i32 %idx
  %res = select i1 %any.set, i64 %extr, i64 %existing
  ret i64 %res
}

define float @clastb_float(float %existing, <vscale x 4 x float> %data, <vscale x 4 x i1> %pg) {
; CHECK-LABEL: clastb_float:
; CHECK:       // %bb.0:
; CHECK-NEXT:    clastb s0, p0, s0, z1.s
; CHECK-NEXT:    ret
  %rev.pg = call <vscale x 4 x i1> @llvm.vector.reverse.nxv4i1(<vscale x 4 x i1> %pg)
  %tz.cnt = call i32 @llvm.experimental.cttz.elts.float.nxv4i1(<vscale x 4 x i1> %rev.pg, i1 false)
  %any.set = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> %pg)
  %vscale = call i32 @llvm.vscale.float()
  %size = shl i32 %vscale, 2
  %sub = sub i32 %size, %tz.cnt
  %idx = sub i32 %sub, 1
  %extr = extractelement <vscale x 4 x float> %data, i32 %idx
  %res = select i1 %any.set, float %extr, float %existing
  ret float %res
}

define double @clastb_double(double %existing, <vscale x 2 x double> %data, <vscale x 2 x i1> %pg) {
; CHECK-LABEL: clastb_double:
; CHECK:       // %bb.0:
; CHECK-NEXT:    clastb d0, p0, d0, z1.d
; CHECK-NEXT:    ret
  %rev.pg = call <vscale x 2 x i1> @llvm.vector.reverse.nxv2i1(<vscale x 2 x i1> %pg)
  %tz.cnt = call i32 @llvm.experimental.cttz.elts.i32.nxv2i1(<vscale x 2 x i1> %rev.pg, i1 false)
  %any.set = call i1 @llvm.vector.reduce.or.nxv2i1(<vscale x 2 x i1> %pg)
  %vscale = call i32 @llvm.vscale.i32()
  %size = shl i32 %vscale, 1
  %sub = sub i32 %size, %tz.cnt
  %idx = sub i32 %sub, 1
  %extr = extractelement <vscale x 2 x double> %data, i32 %idx
  %res = select i1 %any.set, double %extr, double %existing
  ret double %res
}
